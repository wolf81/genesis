# GENESIS

*"In the beginning God created the heaven and the earth."*
	- The Bible, Genesis 1 verse 1

Genesis is a Lua / LÃ–VE2D based world generator. While this library wont allow 
anyone to create a heaven, at least one can create an earth, so halfway there to
becoming a god :)

My goals with Genesis are:

* To have a library that can be easily integrated into games
* To be able to generate interesting random patterns
* Worlds should be seedable: the same seed value should generate the same world
* Worlds should be easily usable with cubemaps
* Worlds should have biomes, rivers, seas, lakes, mountains
* Allow some configuration of the generator, e.g. detail level

# CONCEPTS

The maps that are generated by Genesis are based around a cube. As such, every
time a world map is generated, actually there will be 6 face maps generated, one 
for each side of an imaginary cube.

The faces are oriented as such:

	5
	1 2 3 4
	6

So face number 5 is the north pole, face number 6 the south pole. The equator 
runs through faces 1 to 4. 

A face is compromised of tiles. Tiles contain various data for a coordinate on 
the cube, like the height, heat and moisture values.

# API

## Genesis

The API is still a work-in-progress and as such, subject to change. With that 
said what follows is a short description of the API at time of writing.

In order to create a world, we first need to create an instance of the Genesis 
class:

```lua
local genesis = Genesis() --> returns a new Genesis instance
```

To generate a new map, just call the `generate` function with a size and 
optionally a seed value. When using the same seed value, the same map will be 
created. In no seed value is supplied, a random seed will be used.

```lua
genesis:generate(100) --> generates a map of 6 x 100 x 100
```

It's possible to request the width and the height of a face of the map. Since 
each face map is a square, the width and height will be equal. 

```lua
local w, h = genesis:getSize() --> returns 100 x 100

local s = genesis:getSize() --> returns 100
```

After a map is generated, it is possible to request tiles based on face number, 
x- and y-coordinates. The x and y coordinates are 0 indexed while the faces are 
indexed from 1 to 6 (I might need to align this in the future).

```lua
local tile = genesis:getTile(1, 0, 3) --> returns Tile object
```

The above code retrieves the tile for face 1, x coordinate 0, y coordinate 3.

It's easy to loop through all the tiles in a map as such:

```lua
local w, h = genesis:getSize()

for face = 1, 6 do
	for x = 0, w - 1 do
		for y = 0, h - 1 do
			local tile = genesis:getTile(face, x, y)
			-- do something with the tile here ...
		end
	end
end
```

## Tile

With regards to a `Tile` I won't explain every function, just the most important 
ones.

```lua
tile:getHeightValue() --> gets a value indicating height level, e.g. 0.95
tile:getHeightType() --> gets an integer indicating the height type, e.g. 3

tile:getHeatValue() --> gets a value indicating heat level, e.g. 0.33
tile:getHeatType() --> gets an integer indicating the heat type, e.g. 4

tile:getMoistureValue() --> gets a value indicating moisture level, e.g. 0.17
tile:getMoistureType() --> gets an integer indicating the moisture type, e.g. 5
```

The `get___Value()` functions will return normalized values in 0.0 to 1.0 range. 
These values are suitable for rendering tiles with smooth color changes (e.g. 
grayscale rendering of a height map). 

The `get___Type()` functions will return string contants. The string constants 
are defined in `constants.lua`. These values are suitable for drawing tiles
with a solid color.

Another useful function for figuring out if an adjacent tile has the same 
terrain type or biome is the `getFlags()` function. The value returned can 
contain various TileFlags as defined in `constants.lua`. In order to check if 
all adjacent tiles are of same height type as current tile, we can check as 
follows:

```lua
bit.band(tile:getFlags(), TileFlags.EQ_HEIGHT_ALL) == TileFlags.EQ_HEIGHT_ALL
```
	
# FURTHER READING

The Genesis source code is based on a variety of ideas and posts found on the 
internet. For reference I've added the most important links here.

* [Procedurally Generating Wrapping World Maps in Unity C#][0]
* [Wraparound square tile maps on a sphere][1]
* [Creating tileable noise maps][2]
* [Making maps with noise functions][3]
* [Fractal Brownian Motion][4]

[0]: http://www.jgallant.com/procedurally-generating-wrapping-world-maps-in-unity-csharp-part-1
[1]: https://www.redblobgames.com/x/1938-square-tiling-of-sphere/
[2]: https://ronvalstar.nl/creating-tileable-noise-maps
[3]: https://www.redblobgames.com/maps/terrain-from-noise/
[4]: https://thebookofshaders.com/13/
